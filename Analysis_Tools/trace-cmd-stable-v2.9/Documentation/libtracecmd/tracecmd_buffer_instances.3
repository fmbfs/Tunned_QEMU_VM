'\" t
.\"     Title: libtracecmd
.\"    Author: [see the "AUTHOR" section]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 03/31/2022
.\"    Manual: libtracefs Manual
.\"    Source: libtracefs
.\"  Language: English
.\"
.TH "LIBTRACECMD" "3" "03/31/2022" "libtracefs" "libtracefs Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
tracecmd_buffer_instances, tracecmd_buffer_instance_name, tracecmd_buffer_instance_handle \- Read tracing instances from a trace file\&.
.SH "SYNOPSIS"
.sp
.nf
\fB#include <trace\-cmd\&.h>\fR

int \fBtracecmd_buffer_instances\fR(struct tracecmd_input *\fIhandle\fR);
const char *\fBtracecmd_buffer_instance_name\fR(struct tracecmd_input *\fIhandle\fR, int \fIindx\fR);
struct tracecmd_input *\fBtracecmd_buffer_instance_handle\fR(struct tracecmd_input *\fIhandle\fR, int \fIindx\fR);
.fi
.SH "DESCRIPTION"
.sp
This set of APIs can be used to get information and read tracing data from tracing instances stored in a trace file\&.
.sp
The \fItracecmd_buffer_instances()\fR function gets the number of tracing instances recorded in a trace file\&. The top instance is not counted\&. The \fIhandle\fR is a tracecmd_input handler returned by \fItracecmd_open_head()\fR\&.
.sp
The \fItracecmd_buffer_instance_name()\fR function gets the name of the tracing instance with given index \fIindx\fR, recorded in a trace file\&. The \fIindx\fR is a number in the interval [0 \&.\&. count\-1], where count is the number returned by \fItracecmd_buffer_instances()\fR\&. The \fIhandle\fR is a tracecmd_input handler returned by \fItracecmd_open_head()\fR\&.
.sp
The \fItracecmd_buffer_instance_handle()\fR allocates and initializes a tracecmd_input handle, associated with trace instance with index \fIindx\fR from a trace file\&. The \fIhandle\fR is a tracecmd_input handler returned by \fItracecmd_open_head()\fR\&. The \fIindx\fR is a number in the interval [0 \&.\&. count\-1], where count is the number returned by \fItracecmd_buffer_instances()\fR\&.
.SH "RETURN VALUE"
.sp
The \fItracecmd_buffer_instances()\fR function returns the number of tracing instances recorded in a trace file\&.
.sp
The \fItracecmd_buffer_instance_name()\fR function returns a string, the name of a tracing instance, or NULL in case of an error The string must \fBnot\fR be freed\&.
.sp
The \fItracecmd_buffer_instance_handle()\fR function returns a pointer to newly allocated tracecmd_input handler or NULL in case if an error\&. The returned handler must be closed by \fItracecmd_close()(3)\fR
.SH "EXAMPLE"
.sp
.if n \{\
.RS 4
.\}
.nf
#include <trace\-cmd\&.h>
\&.\&.\&.
struct tracecmd_input *handle = tracecmd_open_head("trace\&.dat");
        if (!handle) {
                /* Failed to open trace\&.dat file */
        }
\&.\&.\&.
int num = tracecmd_buffer_instances(handle);

        while(num) {
                struct tracecmd_input *h;
                char *name;

                name = tracecmd_buffer_instance_name(handle, num);
                if (!name) {
                        /* Failed to get name of instance num */
                }
                h = tracecmd_buffer_instance_handle(handle, num);
                if (!h) {
                        /* Failed to initialize handler for instance num */
                }

                \&.\&.\&.
                tracecmd_close(h);
                num\-\-;
        }
\&.\&.\&.
        tracecmd_close(handle);
.fi
.if n \{\
.RE
.\}
.SH "FILES"
.sp
.if n \{\
.RS 4
.\}
.nf
\fBtrace\-cmd\&.h\fR
        Header file to include in order to have access to the library APIs\&.
\fB\-ltracecmd\fR
        Linker switch to add when building a program that uses the library\&.
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.sp
\fIlibtracefs(3)\fR, \fIlibtraceevent(3)\fR, \fItrace\-cmd(1)\fR \fItrace\-cmd\&.dat(5)\fR
.SH "AUTHOR"
.sp
.if n \{\
.RS 4
.\}
.nf
\fBSteven Rostedt\fR <\m[blue]\fBrostedt@goodmis\&.org\fR\m[]\&\s-2\u[1]\d\s+2>
\fBTzvetomir Stoyanov\fR <\m[blue]\fBtz\&.stoyanov@gmail\&.com\fR\m[]\&\s-2\u[2]\d\s+2>
.fi
.if n \{\
.RE
.\}
.SH "REPORTING BUGS"
.sp
Report bugs to <\m[blue]\fBlinux\-trace\-devel@vger\&.kernel\&.org\fR\m[]\&\s-2\u[3]\d\s+2>
.SH "LICENSE"
.sp
libtracecmd is Free Software licensed under the GNU LGPL 2\&.1
.SH "RESOURCES"
.sp
\m[blue]\fBhttps://git\&.kernel\&.org/pub/scm/utils/trace\-cmd/trace\-cmd\&.git/\fR\m[]
.SH "COPYING"
.sp
Copyright (C) 2020 VMware, Inc\&. Free use of this software is granted under the terms of the GNU Public License (GPL)\&.
.SH "NOTES"
.IP " 1." 4
rostedt@goodmis.org
.RS 4
\%mailto:rostedt@goodmis.org
.RE
.IP " 2." 4
tz.stoyanov@gmail.com
.RS 4
\%mailto:tz.stoyanov@gmail.com
.RE
.IP " 3." 4
linux-trace-devel@vger.kernel.org
.RS 4
\%mailto:linux-trace-devel@vger.kernel.org
.RE
