'\" t
.\"     Title: libtracecmd
.\"    Author: [see the "AUTHOR" section]
.\" Generator: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Date: 03/31/2022
.\"    Manual: libtracefs Manual
.\"    Source: libtracefs
.\"  Language: English
.\"
.TH "LIBTRACECMD" "3" "03/31/2022" "libtracefs" "libtracefs Manual"
.\" -----------------------------------------------------------------
.\" * Define some portability stuff
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\" -----------------------------------------------------------------
.\" * set default formatting
.\" -----------------------------------------------------------------
.\" disable hyphenation
.nh
.\" disable justification (adjust text to left margin only)
.ad l
.\" -----------------------------------------------------------------
.\" * MAIN CONTENT STARTS HERE *
.\" -----------------------------------------------------------------
.SH "NAME"
tracecmd_read_cpu_first, tracecmd_read_data, tracecmd_read_at, tracecmd_free_record, tracecmd_get_tep \- Read recorded events from a trace file\&.
.SH "SYNOPSIS"
.sp
.nf
\fB#include <trace\-cmd\&.h>\fR

struct tep_record *\fBtracecmd_read_cpu_first\fR(struct tracecmd_input *\fIhandle\fR, int \fIcpu\fR);
struct tep_record *\fBtracecmd_read_data\fR(struct tracecmd_input *\fIhandle\fR, int \fIcpu\fR);
struct tep_record *\fBtracecmd_read_at\fR(struct tracecmd_input *\fIhandle\fR, unsigned long long \fIoffset\fR, int *\fIcpu\fR);
void \fBtracecmd_free_record\fR(struct tep_record *\fIrecord\fR);
struct tep_handle *\fBtracecmd_get_tep\fR(struct tracecmd_input *\fIhandle\fR);
.fi
.SH "DESCRIPTION"
.sp
This set of APIs can be used to read tracing data from a trace file opened with \fItracecmd_open()(3)\fR, \fItracecmd_open_fd()(3)\fR or \fItracecmd_open_head()(3)\fR\&.
.sp
The \fItracecmd_read_cpu_first()\fR function reads the first trace record for a given \fIcpu\fR from a trace file associated with \fIhandle\fR\&. The returned record must be freed with \fItracecmd_free_record()\fR\&.
.sp
The \fItracecmd_read_data()\fR function reads the next trace record for a given \fIcpu\fR from a trace file associated with \fIhandle\fR and increments the read location pointer, so that the next call to \fItracecmd_read_data()\fR will not read the same record again\&. The returned record must be freed with \fItracecmd_free_record()\fR\&.
.sp
The \fItracecmd_read_at()\fR function reads a trace record from a specific \fIoffset\fR within the file associated with \fIhandle\fR\&. The CPU on which the recorded event occurred is stored in the \fIcpu\fR\&. The function does not change the current read location pointer\&. The returned record must be freed with \fItracecmd_free_record()\fR\&.
.sp
The \fItracecmd_free_record()\fR function frees a \fIrecord\fR returned by any of the \fItracecmd_read_\fR APIs\&.
.sp
The \fItracecmd_get_tep()\fR function returns a tep context for a given \fIhandle\fR\&.
.SH "RETURN VALUE"
.sp
The \fItracecmd_read_cpu_first()\fR, \fItracecmd_read_data()\fR and \fItracecmd_read_at()\fR functions return a pointer to struct tep_record or NULL in case of an error\&.The returned record must be freed with \fItracecmd_free_record()\fR\&.
.sp
The \fItracecmd_get_tep()\fR function returns a pointer to tep context or NULL if there is no tep context for the given \fIhandle\fR\&. The returned tep pointer must \fBnot\fR be freed\&.
.SH "EXAMPLE"
.sp
.if n \{\
.RS 4
.\}
.nf
#include <trace\-cmd\&.h>
\&.\&.\&.
struct tracecmd_input *handle = tracecmd_open("trace\&.dat");
        if (!handle) {
                /* Failed to open trace\&.dat file */
        }
\&.\&.\&.
unsigned long long offset = 0;
struct tep_record *rec;
int cpu = 0;
        rec = tracecmd_read_cpu_first(handle, cpu);
        while (rec) {
                \&.\&.\&.
                if ( /* some interesting record noticed */) {
                        /* store the offset of the interesting record */
                        offset = rec\->offset;
                }
                \&.\&.\&.
                tracecmd_free_record(rec);
                rec = tracecmd_read_data(handle, cpu);
        }
        \&.\&.\&.
        if (offset) {
                rec = tracecmd_read_at(handle, offset, &cpu);
                if (rec) {
                        /* Got record at offset on cpu */
                        \&.\&.\&.
                        tracecmd_free_record(rec);
                }
        }

\&.\&.\&.
        tracecmd_close(hadle);
.fi
.if n \{\
.RE
.\}
.SH "FILES"
.sp
.if n \{\
.RS 4
.\}
.nf
\fBtrace\-cmd\&.h\fR
        Header file to include in order to have access to the library APIs\&.
\fB\-ltracecmd\fR
        Linker switch to add when building a program that uses the library\&.
.fi
.if n \{\
.RE
.\}
.SH "SEE ALSO"
.sp
\fIlibtracefs(3)\fR, \fIlibtraceevent(3)\fR, \fItrace\-cmd(1)\fR \fItrace\-cmd\&.dat(5)\fR
.SH "AUTHOR"
.sp
.if n \{\
.RS 4
.\}
.nf
\fBSteven Rostedt\fR <\m[blue]\fBrostedt@goodmis\&.org\fR\m[]\&\s-2\u[1]\d\s+2>
\fBTzvetomir Stoyanov\fR <\m[blue]\fBtz\&.stoyanov@gmail\&.com\fR\m[]\&\s-2\u[2]\d\s+2>
.fi
.if n \{\
.RE
.\}
.SH "REPORTING BUGS"
.sp
Report bugs to <\m[blue]\fBlinux\-trace\-devel@vger\&.kernel\&.org\fR\m[]\&\s-2\u[3]\d\s+2>
.SH "LICENSE"
.sp
libtracecmd is Free Software licensed under the GNU LGPL 2\&.1
.SH "RESOURCES"
.sp
\m[blue]\fBhttps://git\&.kernel\&.org/pub/scm/utils/trace\-cmd/trace\-cmd\&.git/\fR\m[]
.SH "COPYING"
.sp
Copyright (C) 2020 VMware, Inc\&. Free use of this software is granted under the terms of the GNU Public License (GPL)\&.
.SH "NOTES"
.IP " 1." 4
rostedt@goodmis.org
.RS 4
\%mailto:rostedt@goodmis.org
.RE
.IP " 2." 4
tz.stoyanov@gmail.com
.RS 4
\%mailto:tz.stoyanov@gmail.com
.RE
.IP " 3." 4
linux-trace-devel@vger.kernel.org
.RS 4
\%mailto:linux-trace-devel@vger.kernel.org
.RE
